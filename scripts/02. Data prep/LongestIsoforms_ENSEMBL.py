#! /usr/bin/env python3

import sys
import re
from itertools import groupby

print(
"""
This is LongestIsoforms_NCBI.py
Usage: LongestIsoforms_NCBI.py input.fa output.fa
"""
)

input_file = sys.argv[1]
output_file = sys.argv[2]



print("the input file is: "+input_file)
print("the output file is: "+output_file)


def fasta_parse(fasta_iterator): #when given a fasta file, the function yields tuples of (header, sequence)
	with open(fasta_iterator) as f:
		fasta_iterator = (x[1] for x in groupby(f, lambda line: line[0] == ">")) #create alternating groups of lines starting by > and the others
		for line in fasta_iterator:
			header_string = line.__next__()[1:].strip()		#line[0] is the ">", so everything else on the line is the header string
			sequence = "".join(s.strip() for s in fasta_iterator.__next__())  #We join all the objects in the list following the header list (groupby output)
			Search_string = 'gene\:([^\s]+)'
			gene_name = re.search(Search_string, header_string).group(1)
			yield (header_string, sequence, gene_name)


fasta = fasta_parse(input_file) #calls the function we defined to parse the file passed as an argument

output = []

#The groupby creates a generator, and the if and else loops iterate through it.
#If you uncomment the block with the print statements, the generator will be exhausted, so the output file (generated by the second block) will be empty.
"""

for sublist_iterator in groupby(sorted(fasta, key = lambda x: x[2]), lambda x: x[2]): #group sequences by gene names. Groupby works only on contiguous lines, so we need to sort the lists according to gene names. This way transcripts (sublists) will get fused with contiguous sublists sharing the same gene name.
	gene = list(sublist_iterator[1])  #sublist_iterator[1] is a list of lists. Higher level lists are genes.
	if len(gene) == 1:					#One transcript by gene.
		output.append(">"+str(gene[0][0])+'\n'+str(gene[0][1]))
	else:								#len(gene) only equal or greater than 1. Can't be zero.
		longest_transcript = sorted(gene, key=lambda isoform: isoform[1], reverse = False) #sorted function, the key being the second field of the subsublist (i.e., the sequence)
		output.append(">"+str(longest_transcript[0][0])+'\n'+str(longest_transcript[0][1]))
"""
with open(output_file,"w") as g:
	for sublist_iterator in groupby(sorted(fasta, key = lambda x: x[2]), lambda x: x[2]): #group sequences by gene names. Groupby works only on contiguous lines, so we need to sort the lists according to gene names. This way transcripts (sublists) will get fused with contiguous sublists sharing the same gene name.
		gene = list(sublist_iterator[1])	  #sublist_iterator[1] is a generator of lists. Higher level lists are genes.
		if len(gene) == 1:					#One transcript by gene.
			g.write(">"+str(gene[0][0])+'\n'+str(gene[0][1])+'\n')
		else:								#len(gene) only equal or greater than 1. Can't be zero.
			longest_transcript = sorted(gene, key=lambda isoform: len(isoform[1]), reverse = True) #sorted function, the key being the second field of the subsublist (i.e., the sequence length). In the event that several isoforms have the same length, the alphabetical sorting inherited  by the gene name sorting prevails, and the isoform with the lowest number (e.g. a or X1) and highest sequence length is retained
			g.write(">"+str(longest_transcript[0][0])+'\n'+str(longest_transcript[0][1])+'\n')